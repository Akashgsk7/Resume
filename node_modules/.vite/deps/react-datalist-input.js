import {
  require_react
} from "./chunk-IGOAJGOA.js";
import {
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/react-datalist-input/dist/index.es.js
var import_react = __toESM(require_react());
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
var DEFAULT_IS_EXPANDED = false;
var IS_PRODUCTION = false;
var contextRequiredWarning = function(name) {
  return "The ".concat(name, " component must be a child of Combobox. Please wrap the component inside Combobox to ensure that the required context is available.");
};
function assertWithWarning(condition, text) {
  if (!IS_PRODUCTION) {
    if (condition) {
      return;
    }
    if (typeof console !== "undefined") {
      console.warn(text);
    }
    try {
      throw Error(text);
    } catch (x) {
    }
  }
}
var handleWith = function() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return function(e) {
    return fns.forEach(function(fn) {
      return fn && fn(e);
    });
  };
};
var ComboboxContext = (0, import_react.createContext)({
  contextAvailable: true,
  listboxId: "",
  selectedItemId: "",
  isExpanded: DEFAULT_IS_EXPANDED
});
var useComboboxContext = function() {
  return (0, import_react.useContext)(ComboboxContext);
};
var useComboboxControls = function(params) {
  var _a = useStateRef(params === null || params === void 0 ? void 0 : params.isExpanded), isExpanded = _a[0], setIsExpanded = _a[1];
  var _b = (0, import_react.useState)((params === null || params === void 0 ? void 0 : params.initialValue) || ""), value = _b[0], setValue = _b[1];
  return {
    isExpanded,
    value,
    setIsExpanded,
    setValue
  };
};
function useClassNameStr(className, params) {
  return (0, import_react.useMemo)(function() {
    return !className || typeof className === "string" ? className : className(params);
  }, [params, className]);
}
var useComboboxHelpers = function(_a) {
  var itemsRef = _a.itemsRef, listboxRef = _a.listboxRef, comboboxInputRef = _a.comboboxInputRef, onSelect = _a.onSelect, isExpandedRef = _a.isExpandedRef, setIsExpanded = _a.setIsExpanded, setValue = _a.setValue, setSelectedItem = _a.setSelectedItem;
  var handleChange = (0, import_react.useCallback)(function(e) {
    if (setValue)
      setValue(e.currentTarget.value);
    if (setIsExpanded)
      setIsExpanded(true);
  }, [setValue, setIsExpanded]);
  var expandOnFocus = (0, import_react.useCallback)(function() {
    if (!isExpandedRef.current && setIsExpanded)
      setIsExpanded(true);
  }, [setIsExpanded]);
  var handleCloseDatalist = (0, import_react.useCallback)(function() {
    if (isExpandedRef.current && setIsExpanded)
      setIsExpanded(false);
  }, [setIsExpanded]);
  var closeOnEscape = (0, import_react.useCallback)(function(e) {
    if (e.key === "Escape")
      handleCloseDatalist();
  }, []);
  var handleClickOutside = (0, import_react.useCallback)(function(e) {
    if (!comboboxInputRef.current || !listboxRef.current)
      return;
    var targetElement = e.target;
    if (!targetElement || !listboxRef.current.contains(targetElement) && targetElement !== comboboxInputRef.current) {
      handleCloseDatalist();
    }
  }, [handleCloseDatalist]);
  var handleFocusOutside = (0, import_react.useCallback)(function() {
    if (!comboboxInputRef.current || !listboxRef.current)
      return;
    var activeElement = document.activeElement;
    if (!activeElement || !listboxRef.current.contains(activeElement) && activeElement !== comboboxInputRef.current) {
      handleCloseDatalist();
    }
  }, [handleCloseDatalist]);
  var handleSelect = (0, import_react.useCallback)(function(item) {
    if (comboboxInputRef.current)
      comboboxInputRef.current.focus();
    if (setValue)
      setValue(item.value);
    if (setIsExpanded)
      setIsExpanded(false);
    if (setSelectedItem)
      setSelectedItem(item);
    if (onSelect)
      onSelect(item);
  }, [setValue, onSelect, setIsExpanded, setSelectedItem]);
  var handleKeyDownOnInput = (0, import_react.useCallback)(function(e) {
    var isControlOptionSpace = e.code === "Space" && e.ctrlKey && e.altKey;
    var shouldVisitItems = e.key === "ArrowDown" || isControlOptionSpace;
    if (!listboxRef.current || !shouldVisitItems)
      return;
    if (isControlOptionSpace)
      e.preventDefault();
    if (isExpandedRef.current) {
      var firstOption = listboxRef.current.firstElementChild;
      if (firstOption && typeof firstOption.focus === "function")
        firstOption.focus();
    } else if (setIsExpanded) {
      setIsExpanded(true);
      window.setTimeout(function() {
        if (!listboxRef.current)
          return;
        var firstOption2 = listboxRef.current.firstElementChild;
        if (firstOption2 && typeof firstOption2.focus === "function")
          firstOption2.focus();
      });
    }
  }, [setIsExpanded]);
  var handleKeyDownOnListboxOption = (0, import_react.useCallback)(function(e) {
    if (!itemsRef.current)
      return;
    var item = itemsRef.current.find(function(item2) {
      return item2.id === e.currentTarget.id;
    });
    if (!item)
      return;
    if (e.key === "Enter")
      return handleSelect(item);
    if (!listboxRef.current || e.key === "Escape" || e.key === "Tab" || e.key === "Shift")
      return;
    if (e.key === "ArrowDown" || e.key === "ArrowUp" || e.key === "Alt") {
      e.preventDefault();
      var nextNode = null;
      if (e.key === "ArrowDown" || e.key === "Alt") {
        nextNode = e.currentTarget.nextElementSibling || listboxRef.current.firstElementChild;
      } else {
        nextNode = e.currentTarget.previousElementSibling || listboxRef.current.lastElementChild;
      }
      if (!nextNode)
        return;
      var nextOption = nextNode;
      if (nextOption && typeof nextOption.focus === "function")
        nextOption.focus();
      return;
    }
    if (!comboboxInputRef.current)
      return;
    comboboxInputRef.current.focus();
    comboboxInputRef.current.dispatchEvent(new KeyboardEvent("keydown", { key: e.key }));
  }, [handleSelect]);
  return {
    closeOnEscape,
    handleClickOutside,
    handleFocusOutside,
    handleChange,
    expandOnFocus,
    handleSelect,
    handleKeyDownOnInput,
    handleKeyDownOnListboxOption
  };
};
var ComboboxInput = (0, import_react.forwardRef)(function(_a, forwardedRef) {
  var value = _a.value, props = __rest(_a, ["value"]);
  var _b = useComboboxContext(), contextAvailable = _b.contextAvailable, listboxId = _b.listboxId, isExpanded = _b.isExpanded;
  assertWithWarning(contextAvailable, contextRequiredWarning(ComboboxInput.name));
  return import_react.default.createElement("input", __assign({ autoComplete: "off" }, props, { ref: forwardedRef, value, type: "text", role: "combobox", "aria-autocomplete": "list", "aria-haspopup": "listbox", "aria-expanded": isExpanded, "aria-controls": listboxId }));
});
ComboboxInput.displayName = "ComboboxInput";
var Highlight = function(_a) {
  var children = _a.children, _b = _a.currentInput, currentInput = _b === void 0 ? "" : _b, _c = _a.as, as = _c === void 0 ? "mark" : _c, props = __rest(_a, ["children", "currentInput", "as"]);
  var markedChildren = (0, import_react.useMemo)(function() {
    if (typeof children !== "string") {
      return children;
    }
    var index = children.toLowerCase().indexOf(currentInput.toLowerCase());
    var inputLength = currentInput.length;
    if (index === -1 || !inputLength) {
      return children;
    }
    return import_react.default.createElement(
      import_react.default.Fragment,
      null,
      children.substring(0, index),
      as === "mark" ? import_react.default.createElement("mark", __assign({}, props), children.substring(index, index + inputLength)) : import_react.default.createElement("span", __assign({}, props), children.substring(index, inputLength)),
      children.substring(index + inputLength, children.length)
    );
  }, [currentInput, children]);
  return import_react.default.createElement(import_react.default.Fragment, null, markedChildren);
};
var ListboxOption = (0, import_react.forwardRef)(function(_a, forwardedRef) {
  var children = _a.children, id = _a.id, className = _a.className, props = __rest(_a, ["children", "id", "className"]);
  var selectedItemId = useComboboxContext().selectedItemId;
  var classNameStr = useClassNameStr(className, {
    isSelected: !!id && id === selectedItemId
  });
  return import_react.default.createElement("li", __assign({}, props, { ref: forwardedRef, id, className: classNameStr, role: "option" }), children);
});
ListboxOption.displayName = "ListboxOption";
var Listbox = (0, import_react.forwardRef)(function(_a, forwardedRef) {
  var children = _a.children, props = __rest(_a, ["children"]);
  var _b = useComboboxContext(), contextAvailable = _b.contextAvailable, listboxId = _b.listboxId, isExpanded = _b.isExpanded;
  assertWithWarning(contextAvailable, contextRequiredWarning(Listbox.name));
  var isExpandedRef = (0, import_react.useRef)(isExpanded);
  var _c = (0, import_react.useState)(false), hasExpanded = _c[0], setHasExpanded = _c[1];
  (0, import_react.useEffect)(function() {
    if (!isExpanded) {
      setHasExpanded(false);
    } else if (isExpanded && isExpanded !== isExpandedRef.current) {
      setHasExpanded(true);
    }
    isExpandedRef.current = isExpanded;
  }, [isExpanded]);
  return import_react.default.createElement("ul", __assign({}, props, { ref: forwardedRef, id: listboxId, role: "listbox", "aria-live": hasExpanded ? props["aria-live"] || "polite" : "off" }), children);
});
Listbox.displayName = "Listbox";
var Combobox = function(_a) {
  var listboxId = _a.listboxId, selectedItemId = _a.selectedItemId, _b = _a.isExpanded, isExpanded = _b === void 0 ? true : _b, children = _a.children;
  var id = (0, import_react.useId)();
  return import_react.default.createElement(ComboboxContext.Provider, { value: { contextAvailable: true, listboxId: listboxId || id, selectedItemId, isExpanded } }, children);
};
Combobox.ComboboxInput = ComboboxInput;
Combobox.Listbox = Listbox;
Combobox.ListboxOption = ListboxOption;
Combobox.Highlight = Highlight;
function useStateRef(initalState) {
  var _a = (0, import_react.useState)(initalState), state = _a[0], setState = _a[1];
  var ref = (0, import_react.useRef)(initalState);
  var setStateRef = function(newState) {
    setState(newState);
    ref.current = newState;
  };
  return [state, setStateRef, ref];
}
var useInternalValue = function(value, setValue) {
  var _a = (0, import_react.useState)(value || ""), internalValue = _a[0], setInternalValue = _a[1];
  var setValues = (0, import_react.useCallback)(function(newValue) {
    if (setValue) {
      setValue(newValue);
    } else {
      setInternalValue(newValue);
    }
  }, [setValue]);
  (0, import_react.useEffect)(function() {
    setInternalValue(value || "");
  }, [value]);
  return [internalValue, setValues];
};
var useInternalSelectedItem = function(item) {
  var _a = (0, import_react.useState)(item), selectedItem = _a[0], setSelectedItem = _a[1];
  (0, import_react.useEffect)(function() {
    setSelectedItem(item);
  }, [item]);
  return [selectedItem, setSelectedItem];
};
var startsWithValueFilter = function(items, value) {
  if (value === void 0) {
    value = "";
  }
  return items.filter(function(item) {
    return typeof item.value === "string" ? item.value.substring(0, value.length).toLowerCase() === value.toLowerCase() : true;
  });
};
var includesValueFilter = function(items, value) {
  if (value === void 0) {
    value = "";
  }
  return items.filter(function(item) {
    return typeof item.value === "string" ? item.value.toLowerCase().includes(value.toLocaleLowerCase()) : true;
  });
};
var useFilters = function(items, value, filters) {
  var filteredRef = (0, import_react.useRef)(items);
  var filtered = (0, import_react.useMemo)(function() {
    return filters.reduce(function(currentItems, filter) {
      return filter(currentItems, value);
    }, items);
  }, [items, filters, value]);
  (0, import_react.useEffect)(function() {
    filteredRef.current = filtered;
  }, [filtered]);
  return [filtered, filteredRef];
};
var DatalistInput = (0, import_react.forwardRef)(function(_a, forwardedRef) {
  var label = _a.label, _b = _a.showLabel, showLabel = _b === void 0 ? true : _b, items = _a.items, selectedItem = _a.selectedItem, value = _a.value, setValue = _a.setValue, onSelect = _a.onSelect, placeholder = _a.placeholder, _c = _a.isExpanded, isExpanded = _c === void 0 ? DEFAULT_IS_EXPANDED : _c, setIsExpanded = _a.setIsExpanded, _d = _a.filters, filters = _d === void 0 ? [includesValueFilter] : _d, inputProps = _a.inputProps, labelProps = _a.labelProps, listboxOptionProps = _a.listboxOptionProps, listboxProps = _a.listboxProps, _e = _a.isExpandedClassName, isExpandedClassName = _e === void 0 ? "" : _e, _f = _a.isCollapsedClassName, isCollapsedClassName = _f === void 0 ? "" : _f, isExpandedStyle = _a.isExpandedStyle, isCollapsedStyle = _a.isCollapsedStyle, props = __rest(_a, ["label", "showLabel", "items", "selectedItem", "value", "setValue", "onSelect", "placeholder", "isExpanded", "setIsExpanded", "filters", "inputProps", "labelProps", "listboxOptionProps", "listboxProps", "isExpandedClassName", "isCollapsedClassName", "isExpandedStyle", "isCollapsedStyle"]);
  var _g = useStateRef(isExpanded), internalIsExpanded = _g[0], setInternalIsExpanded = _g[1], isExpandedRef = _g[2];
  var _h = useInternalValue(value, setValue), internalValue = _h[0], setInternalValue = _h[1];
  var internalTextboxId = (0, import_react.useId)();
  var debounceValue = (0, import_react.useDeferredValue)(internalValue);
  var _j = useFilters(items, debounceValue, filters), filteredItems = _j[0], filteredItemsRef = _j[1];
  var listboxRef = (0, import_react.useRef)(null);
  var comboboxInputRef = (0, import_react.useRef)(null);
  var _k = useInternalSelectedItem(selectedItem), internalSelectedItem = _k[0], setSelectedItem = _k[1];
  var setIsExpandedStates = (0, import_react.useCallback)(function(state) {
    return setIsExpanded ? setIsExpanded(state) : setInternalIsExpanded(state);
  }, [setIsExpanded]);
  var _l = useComboboxHelpers({
    listboxRef,
    comboboxInputRef,
    isExpandedRef,
    setValue: setInternalValue,
    onSelect,
    itemsRef: filteredItemsRef,
    setIsExpanded: setIsExpandedStates,
    setSelectedItem
  }), handleClickOutside = _l.handleClickOutside, handleFocusOutside = _l.handleFocusOutside, closeOnEscape = _l.closeOnEscape, handleChange = _l.handleChange, expandOnFocus = _l.expandOnFocus, handleSelect = _l.handleSelect, handleKeyDownOnInput = _l.handleKeyDownOnInput, handleKeyDownOnListboxOption = _l.handleKeyDownOnListboxOption;
  (0, import_react.useEffect)(function() {
    setInternalIsExpanded(isExpanded);
  }, [isExpanded]);
  (0, import_react.useEffect)(function() {
    window.addEventListener("click", handleClickOutside);
    window.addEventListener("keyup", closeOnEscape);
    return function() {
      window.removeEventListener("click", handleClickOutside);
      window.removeEventListener("keyup", closeOnEscape);
    };
  }, [handleClickOutside]);
  (0, import_react.useEffect)(function() {
    window.addEventListener("focusin", handleFocusOutside);
    return function() {
      window.removeEventListener("focusin", handleFocusOutside);
    };
  }, [handleFocusOutside]);
  return import_react.default.createElement(
    "div",
    __assign({}, props, { ref: forwardedRef, className: "react-datalist-input__container ".concat(props.className) }),
    import_react.default.createElement(
      Combobox,
      { listboxId: listboxProps === null || listboxProps === void 0 ? void 0 : listboxProps.id, selectedItemId: internalSelectedItem === null || internalSelectedItem === void 0 ? void 0 : internalSelectedItem.id, isExpanded: internalIsExpanded },
      showLabel && import_react.default.createElement("label", __assign({}, labelProps, { className: "react-datalist-input__label ".concat(labelProps === null || labelProps === void 0 ? void 0 : labelProps.className), htmlFor: (inputProps === null || inputProps === void 0 ? void 0 : inputProps.id) || internalTextboxId }), label),
      import_react.default.createElement(ComboboxInput, __assign({}, inputProps, { ref: comboboxInputRef, id: (inputProps === null || inputProps === void 0 ? void 0 : inputProps.id) || internalTextboxId, placeholder, value: internalValue, onClick: handleWith(expandOnFocus, inputProps === null || inputProps === void 0 ? void 0 : inputProps.onClick), onFocus: handleWith(expandOnFocus, inputProps === null || inputProps === void 0 ? void 0 : inputProps.onFocus), onChange: handleWith(handleChange, inputProps === null || inputProps === void 0 ? void 0 : inputProps.onChange), onKeyDown: handleWith(handleKeyDownOnInput, inputProps === null || inputProps === void 0 ? void 0 : inputProps.onKeyDown), "aria-label": !showLabel && typeof label === "string" ? label : void 0, className: "react-datalist-input__textbox ".concat(inputProps === null || inputProps === void 0 ? void 0 : inputProps.className) })),
      (filteredItems.length && internalIsExpanded || isCollapsedClassName || isCollapsedStyle) && import_react.default.createElement(Listbox, __assign({}, listboxProps, { ref: listboxRef, "aria-hidden": internalIsExpanded, className: "react-datalist-input__listbox ".concat(internalIsExpanded ? isExpandedClassName : isCollapsedClassName, " ").concat((listboxProps === null || listboxProps === void 0 ? void 0 : listboxProps.className) || ""), style: __assign(__assign({}, internalIsExpanded ? isExpandedStyle : isCollapsedStyle), listboxProps === null || listboxProps === void 0 ? void 0 : listboxProps.style) }), filteredItems.map(function(item) {
        return import_react.default.createElement(
          ListboxOption,
          __assign({}, listboxOptionProps, { "aria-label": item.label || item.value, key: item.id, id: item.id, tabIndex: -1, onClick: handleWith(function() {
            return handleSelect(item);
          }, listboxOptionProps === null || listboxOptionProps === void 0 ? void 0 : listboxOptionProps.onClick), onKeyDown: handleWith(handleKeyDownOnListboxOption, listboxOptionProps === null || listboxOptionProps === void 0 ? void 0 : listboxOptionProps.onKeyDown), className: "react-datalist-input__listbox-option ".concat(listboxOptionProps === null || listboxOptionProps === void 0 ? void 0 : listboxOptionProps.className) }),
          import_react.default.createElement(Highlight, { currentInput: internalValue }, item.node || item.value)
        );
      }))
    )
  );
});
DatalistInput.displayName = "DatalistInput";

// dep:react-datalist-input
var react_datalist_input_default = DatalistInput;
export {
  Combobox,
  DatalistInput,
  react_datalist_input_default as default,
  includesValueFilter,
  startsWithValueFilter,
  useComboboxContext,
  useComboboxControls,
  useComboboxHelpers,
  useFilters
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=react-datalist-input.js.map
